{
  "author": {
    "name": "Paul Serby",
    "email": "paul@serby.net"
  },
  "name": "compact",
  "description": "A JavaScript compacting middleware for express",
  "version": "0.1.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/serby/compact.git"
  },
  "main": "./lib/compact.js",
  "scripts": {
    "test": "mocha -r should -R spec"
  },
  "engines": {
    "node": ">=0.8"
  },
  "dependencies": {
    "lodash": "~0.3",
    "async": "~0.1",
    "uglify-js": "~1.3",
    "mkdirp": "~0.3"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "~1.1",
    "async": "~0.1",
    "asyncjs": "~0.0"
  },
  "readme": "# compact.js\nA simple JavaScript compacting middleware for express\n\n[![build status](https://secure.travis-ci.org/serby/compact.png)](http://travis-ci.org/serby/compact)\n\n## Installation\n\n    npm install compact\n\n## Usage\n\n### Initialise compact:\n\n```js\nvar compact = require('compact').createCompact({\n  srcPath: __dirname + '/public/src/',\n  destPath: __dirname + '/public/compact/',\n  webPath: '/js/compact/',\n  debug: false\n});\n```\n\n- `srcPath` is the path to your frontend JavaScript. (If you initialised your project with Express' quick start, you probably want to set this to `/public/javascripts`).\n- `destPath` is the path that compact should use to store the compacted assets.\n  If this directory does not exist, it will be created.\n- `webPath` is the public public facing route to your `destPath` (This will preceed the filename of the output `<script>` tags, so `webPath: '/js/compact/' -> <script src=\"/js/compact/myscript.js\">`).\n- `debug` is optional. If set to true, the scripts will not be concatenated or minified.\n\n### Create namespaces:\n\nNamespaces are used to create different compilations of scripts. Usually, you will want to create a `global` namespace that is used everywhere:\n\n```js\ncompact.addNamespace('global');\n\ncompact.ns.global\n  .addJs('/js/main.js')\n  .addJs('/js/widget-a.js')\n  .addJs('/js/widget-b.js');\n```\n\nIf you have some collection of scripts that will only be used on certain pages, it is a good idea to create a namespace for it. For example, if you have a banner and some ads that only appear on the homepage, and some UI that appears only on the profile page/section:\n\n```js\ncompact.addNamespace('home')\n  .addJs('/js/banner.js')\n  .addJs('/js/ads.js');\n\ncompact.addNamespace('profile')\n  .addJs('/js/profile.js');\n```\n\nWhen creating a namespace, you can also pass in an extra `srcPath`. Calls to `addJs()` will look for the file in the given `srcPath`, and if not found it then tries the `srcPath` passed to `createCompact()`.\n\n```js\ncompact.addNamespace('comments',  __dirname + 'libs/comments/public/src/' )\n  .addJs('/js/paging.js')\n  .addJs('/js/comments.js');\n```\n\n### Using the middleware:\n\nIf you have created a `global` namespace, apply it to all routes like so:\n\n```js\napp.use(compact.middleware(['global']));\n```\n\nThis will expose the view helper `compactJsHtml()` in your templates, so you can output the necessary `<script>` tags.\n\nSelectively apply namespaces to routes:\n\n```js\n// Add some compacted JavaScript for just this route. Having the namespaces\n// in separate arrays will produce a javascript file per array.\napp.get(\n  '/',\n  compact.js(['home'], ['profile']),\n  function (req, res) {\n  /* Homepage logic here */\n  }\n);\n\n// Having different namespaces joined together\n// will combine and output as one javascript file.\napp.get(\n  '/',\n  compact.js(['comments', 'profile']),\n  function (req, res) {\n    /* Blog page logic here */\n  }\n);\n```\n\nNote: compact must be applied to your route *before* the route logic. This is so that the view helper is available when you try to render your layout.\n\n### Bulk Config\n\nYou can defined all the namespaces and js files in a JSON schema using the *configure* function.\n\n```js\n\nvar compact = require('compact').createCompact(...);\n\ncompact.configure({\n    prepend: [\n        '/config.js'\n    ],\n\n    append: [\n        '/garbageCollector.js'\n    ],\n\n    cmsSourcePath: '/public/vendor/cms/',\n    cms: [\n        'prepend',\n        '/myModel.js',\n        '/bootstrap.js',\n        'append'\n    ]\n});\n\n```\n\nIn this example you can see that you can either reference a JavaScript file or an existing namespace.\n\n### Rendering\n\nAny route that has `compact.js()` applied will have the helper function `compactJsHtml()` available. This will render the relevant script tags. In Jade, Use like so:\n\n```html\n!=compactJsHtml()\n```\n\nFrom the examples above, on `/` you'd get the following\n\n```html\n<script src=\"/js/compact/global.js\"></script>\n<script src=\"/js/compact/home.js\"></script>\n<script src=\"/js/compact/profile.js\"></script>\n```\n\nAnd on `/blog` you'd get this\n\n```html\n<script src=\"/js/compact/global.js\"></script>\n<script src=\"/js/compact/comment-profile.js\"></script>\n```\n\nYou also have access to the `compactJs()` helper which will return an array\nof files instead of the rendered html.\n\n## Credits\n[Paul Serby](https://github.com/serby/) follow me on [twitter](http://twitter.com/PabloSerbo)\n\n## Licence\nLicenced under the [New BSD License](http://opensource.org/licenses/bsd-license.php)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/serby/compact/issues"
  },
  "homepage": "https://github.com/serby/compact",
  "_id": "compact@0.1.2",
  "dist": {
    "shasum": "95b8c319476a0f8ce6037ec604f7665dd0e1e658"
  },
  "_from": "compact@",
  "_resolved": "https://registry.npmjs.org/compact/-/compact-0.1.2.tgz"
}
