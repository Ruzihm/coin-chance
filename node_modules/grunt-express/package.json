{
  "name": "grunt-express",
  "description": "Start (and supervise) an Express.js web server using grunt.js, works well with socket.io",
  "version": "1.2.1",
  "homepage": "https://github.com/blai/grunt-express",
  "author": {
    "name": "Brian Lai"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/blai/grunt-express.git"
  },
  "bugs": {
    "url": "https://github.com/blai/grunt-express/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "main": "Gruntfile.js",
  "engines": {
    "node": ">= 0.8.0"
  },
  "scripts": {
    "test": "grunt test"
  },
  "dependencies": {
    "connect": "~2.7.8",
    "temp": "~0.5.0",
    "touch": "~0.0.2",
    "connect-livereload": "~0.2.0",
    "lodash": "~1.3.1",
    "grunt-contrib-watch": "~0.5.3",
    "open": "~0.0.4",
    "grunt-parallel": "~0.3.1"
  },
  "devDependencies": {
    "grunt-contrib-jshint": "~0.6.0",
    "express": "~3.2.2",
    "grunt-contrib-nodeunit": "~0.2.0",
    "grunt": "~0.4.1",
    "matchdep": "~0.1.2",
    "request": "~2.22.0"
  },
  "peerDependencies": {
    "grunt": "~0.4.0"
  },
  "keywords": [
    "gruntplugin",
    "server",
    "express",
    "connect",
    "socket.io",
    "livereload",
    "keepalive",
    "watch",
    "http"
  ],
  "readme": "# grunt-express [![Build Status](https://secure.travis-ci.org/blai/grunt-express.png?branch=master)](http://travis-ci.org/blai/grunt-express) [![Dependency Status](https://gemnasium.com/blai/grunt-express.png)](https://gemnasium.com/blai/grunt-express)\n\n## grunt-express v1.0\nv1.0 is nearly a complete re-done, it acts as a higher-level grunt task that depends on (and consumes) `grunt-contrib-watch`. It will dynamically configure `watch` tasks based on your `express` task setup at runtime, and it will run `watch` if necessary. Here's the list of high level changes\n\n1. use `grunt-contrib-watch` to manage reloading express server, instead of `forever-monitor` \n2. support both `livereload` and `serverreload` (pre-v1.0 users: `grunt-express` will no longer manage to restart your server by default, you would have to set `serverreload` to `true` to regain the old behavior)\n3. if `serverreload` is set to `false` in `options`, then the following are true:\n    * server will be started in the same process as your `grunt` (so developers can run debugger using Webstorm or other tools)\n    * server will be run WITHOUT the `this.async()` call (you can optionally append the task `express-keepalive` to keep the server running), this allows you to run tests using grunt-express\n4. continue to support `socket.io` + `express` use cases\n5. discontinue support of `express-stop`\n\n> I am in process to add more test cases to cover all use cases\n\n\n\n## Sample app\n[grunt-express-angular-example](https://github.com/blai/grunt-express-angular-example) is a minimal example that shows how you can use `grunt-express` to run a basic `express` server that hosts an Angular app, it is based on @bford's Yeoman generator `generator-angular`.\n\n\n\n## Getting Started\nThis plugin requires Grunt `~0.4.0`\n\nIf you haven't used [Grunt](http://gruntjs.com/) before, be sure to check out the [Getting Started](http://gruntjs.com/getting-started) guide, as it explains how to create a [Gruntfile](http://gruntjs.com/sample-gruntfile) as well as install and use Grunt plugins. Once you're familiar with that process, you may install this plugin with this command:\n\n```shell\nnpm install grunt-express --save-dev\n```\n\nOnce the plugin has been installed, it may be enabled inside your Gruntfile with this line of JavaScript:\n\n```js\ngrunt.loadNpmTasks('grunt-express');\n```\n\n\n## Express task\n\n### express (main task, Multi Tasks)\n_Run this task with the `grunt express` command._\n\nConfigure one or more servers for grunt to start, the minimal config would be:\n\n```javascript\n  grunt.initConfig({\n    express: {\n      default_option: {}\n    }\n  });\n\n  grunt.loadNpmTasks('grunt-express');\n\n  grunt.registerTask('default', ['express']);\n```\n\n### express-start\n### express-restart\n\nStart your express server (or restart a server if it is already started).\n\n### express-keepalive\n\nNote that when `serverreload` is false, this server only runs as long as grunt is running. Once grunt's tasks have completed, the web server stops. This behavior can be changed by appending a `express-keepalive` task at the end of your task list like so\n\n```javascript\ngrunt.registerTask('myServer', ['express', 'express-keepalive']);\n```\nNow when you run `grunt myServer`, your express server will be kept alive until you manually terminate it.\n\n Such feature can also be enabled ad-hoc by running the command like `grunt express express-keepalive`.\n\nThis design gives you the flexibility to use `grunt-express` in conjunction with another task that is run immediately afterwards, like the [grunt-contrib-qunit plugin](https://github.com/gruntjs/grunt-contrib-qunit) `qunit` task. If we force `express` task to be always async, such use case can no longer happen.\n\n\n\n## Options\n\nAll options of `grunt-express` are optional, if you specify nothing, it will start a `connect` server using port 3000 (which serves nothing).\n\n#### port\nType: `Integer`\nDefault: `3000`\n\nThe port on which the webserver will respond. The task will fail if the specified port is already in use.\n\n#### hostname\nType: `String`\nDefault: `'localhost'`\n\nThe hostname the webserver will use. If set to `'*'`, server could be accessed from ip (e.g. 127.0.0.1) as well as `localhost`\n\n#### bases\nType: `String|Array`\nDefault: `null`\n\nThe bases (or root) directories from which static files will be served. A `connect.static()` will be generated for each entry of `bases`. When `livereload` is set to `true` (or set to a specific port number), a `watch` task will be created for you (at runtime) to watch your `basePath/**/*.*`.\n\nYou may optionally define a placeholder middleware named `staticsPlaceholder` in your server's list of middlewares, and when one is defined, every `connect.static()` middleware generated from your `bases` will be inserted before your `staticsPlaceholder` middleware. If you do not define a `staticsPlaceholder`, your `connect.static()` will be appended at the end of the middleware stack.\n\n##### `staticsPlaceholder` example\n```js\napp.use(function staticsPlaceholder(req, res, next) {\n  return next();\n});\n```\n\n#### server\nType: `String`\nDefault: null\n\nThis option allows you to specify a path to a Node.js module that exports a \"connect-like\" object. Such object should have the following two functions:\n\n1. `use(route, fn)` (https://github.com/senchalabs/connect/blob/master/lib/proto.js#L62)\n2. `listen()` (https://github.com/senchalabs/connect/blob/master/lib/proto.js#L227)\n_note: you DO NOT want to call the listen() from within your server module, `express` task will take care of that for you_\n\nThe simplest example would be:\n```js\nvar connect = require('connect');\nmodule.exports = connect();\n```\n\nor if you prefer express.js\n```js\nvar express = require('express');\nvar app = express();\napp.get('/', function(req, res) {\n  res.send('hello!');\n});\nmodule.exports = app;\n```\n\nor if you want to use both express and socket.io\n```js\nvar app = require('express')()\n  , server = require('http').createServer(app)\n  , io = require('socket.io').listen(server);\n\napp.get('/', function (req, res) {\n  res.sendfile(__dirname + '/index.html');\n});\n\nio.sockets.on('connection', function (socket) {\n  socket.emit('news', { hello: 'world' });\n  socket.on('my other event', function (data) {\n    console.log(data);\n  });\n});\n\nexports = module.exports = server;\n// delegates user() function\nexports.use = function() {\n  app.use.apply(app, arguments);\n};\n```\n\nWhen `server` option is not set, `express` task will generate a plain `connect` object for you.\n\n_note: `express` task will generate `static` middleware for each of the `bases` you specified, and load them onto your server (or the generated server) object by calling `use()` function_\n\n#### livereload\nType: `Boolean|Number`\nDefault: `false`\n\nThis options allows you to define the livereload port (or if you set it to `true`, it will use the default livereload port: `35729`), and when you also define `bases` options, then the livereload server will be watching all contents under your `bases` folder, and perform livereload when those contents change.\n\nWhen livereload is set, a [connect-livereload](https://github.com/intesso/connect-livereload) middleware will be inserted at the top of your server's middleware stack (so you don't have to do the extra step as intructed by [grunt-contrib-connnect's documentation](https://github.com/gruntjs/grunt-contrib-watch#enabling-live-reload-in-your-html))\n\n#### serverreload\nType: `Boolean`\nDefault: `false`\n\nSetting this option to `true` will tell `express` task to start a forever running server in a child process, and if any of your server scripts change, the server will be restarted (using a dynamically generated `watch` task)\n\nWhen this options is not set (or set to `false`), the server will be running in the same process as grunt, and will only live as long as the grunt process is running. You may optionally use `express-keepalive` task to keep it alive.\n\n#### showStack\nType: `Boolean`\nDefault: `false`\n\nSetting this option to `true` will tell `express` task to show the full error stack, if an error occurs in your `express` server.\n\n#### watch (experimental)\nType: `Object`\n\nIf you set `serverreload` (to `true`), a `grunt-contrib-watch` task config would be generated for you to manage the express server. In which case, you can optionally define a `watch` option to control the configuration of such `watch` task. There are, however, a few settings (that `grunt-express` is relying on) you may not change, they are as follow:\n\n```js\nvar watcherOptions = {\n  interrupt: true,\n  atBegin: true,\n  event: ['added', 'changed']\n}\n```\n\n#### middleware (experimental)\nType: `Array`\nDefault: `null`\n\nTry to mimic `grunt-contrib-connect`'s `middleware` options (and should work the same way). Like `bases` options, you can control the insertion point of your `middleware` by adding a `middlewarePlaceholder`, like so:\n\n```js\napp.use(function middlewarePlaceholder(req, res, next) {\n  return next();\n});\n```\n\n#### open (mimics [grunt-contrib-connect#open](https://github.com/gruntjs/grunt-contrib-connect#open))\nType: `Boolean` or `String`\nDefault: `false`\n\nOpen the served page in your default browser. Specifying `true` opens the default server URL, while specifying a URL opens that URL.\n\n#### monitor (WARN: no longer availabe in 1.0+)\n#### Please use a trailing `serverreload` option instead\nType: `Object`\nDefault: `null`\n\nUnder the hood `grunt-express` uses [forever-monitor](https://github.com/nodejitsu/forever-monitor) to manage individual servers in separate child processes. This makes restarting the server automatically possible. This property allow you to pass in the `forever-monitor` options. When specified, the object will be used as the options hash when creating the forever monitor to manage the server in child process.\n\n#### keepalive (WARN: no longer availabe in 0.20+)\n#### Please use a trailing `express-keepalive` task instead\nType: `Boolean`\nDefault: `false`\n\nKeep the server alive indefinitely. Note that if this option is enabled, any tasks specified after this task will _never run_. By default, once grunt's tasks have completed, the web server stops. This option changes that behavior.\n\n#### monitor (WARN: no longer availabe in 1.0+)\n#### debug (WARN: no longer availabe in 1.0+)\nType: `Boolean`\nDefault: `false`\n\nTurning this option on will make the \"supervised\" express|connect instance output more debugging messages.\n\n\n\n### Usage examples\n\n#### Basic Use\nIn this example, `grunt express` (or more verbosely, `grunt express:server`) will start a static web server at `http://localhost:9000/`, with its base path set to the `public` directory relative to the gruntfile, and any tasks run afterwards will be able to access it.\n\n```javascript\n// Project configuration.\ngrunt.initConfig({\n  express: {\n    server: {\n      options: {\n        port: 9000,\n        bases: 'public'\n      }\n    }\n  }\n});\n```\n\nYou may specify more than one `bases` like so. Enhancing the above example, now your server will server static content from both `public` folder and `dist` folder (both are relative path to the `Gruntfile.js`)\n\n```javascript\n// Project configuration.\ngrunt.initConfig({\n  express: {\n    server: {\n      options: {\n        port: 9001,\n        bases: ['public', 'dist']\n      }\n    }\n  }\n});\n```\n\nIf you want your web server to use the default options, just omit the `options` object. You still need to specify a target (`uses_defaults` in this example), but the target's configuration object can otherwise be empty or nonexistent. In this example, `grunt express` (or more verbosely, `grunt express:uses_defaults`) will start a static web server using the default options.\n\n```javascript\n// Project configuration.\ngrunt.initConfig({\n  express: {\n    uses_defaults: {}\n  }\n});\n```\n\nBut usually, you want to start an express server using your own express application script, like so:\n\n```javascript\n// Project configuration.\ngrunt.initConfig({\n  express: {\n    myServer: {\n      server: path.resolve(__dirname, 'server.js')\n      // if you do not define a port it will start your server at port 3000\n    }\n  }\n});\n```\n\n#### Livereload (both server and browser)\n\n`grunt-express` leaves the control on your hands to perform livereload for your express server and the browser contents (e.g. html, javascript, css). You can set the `livereload` and `serverreload` respectively like following:\n\n```js\ngrunt.initConfig({\n  express: {\n    livereloadServer: {\n      server: path.resolve(__dirname, 'server'),\n      bases: path.resolve(__dirname, 'public'),\n      livereload: true, // if you just specify `true`, default port `35729` will be used\n      serverreload: true\n    }\n  }\n});\n```\n\nIf all you have are the browser side static contents, you can omit the `server` option (and of course, you would not set `serverreload` to `true` in this case, although it would not hurt to set it):\n\n```js\ngrunt.initConfig({\n  express: {\n    myLivereloadServer: {\n      bases: path.resolve(__dirname, 'public'),\n      livereload: true\n    }\n  }\n});\n```\nThe above example is equivalent to the following:\n\n```js\nvar LIVERELOAD_PORT = 35729;\nvar lrSnippet = require('connect-livereload')({ port: LIVERELOAD_PORT });\nvar mountFolder = function (connect, dir) {\n  return connect.static(require('path').resolve(dir));\n};\n\ngrunt.initConfig({\n  watch: {\n    options: {\n      livereload: LIVERELOAD_PORT\n    },\n    files: [\n      path.resolve(__dirname, 'public') + '/{,*/}*.*'\n    ]\n  },\n  connect: {\n    livereload: {\n      options: {\n        port: 3000,\n        middleware: function (connect) {\n          return [\n            lrSnippet,\n            mountFolder(connect, path.resolve(__dirname, 'public')),\n            mountFolder(connect, yeomanConfig.app)\n          ];\n        }\n      }\n    }\n  }\n});\n```\n\n#### Managing static content and dynamic middlewares\n\nNoted that `grunt-exress` translates each of your static folders (defined as `bases` option) into an instance of express.static() middleware. And in the case of `livereload` is `true` (or a port number), `grunt-express` will also insert a [connect-livereload](https://github.com/intesso/connect-livereload) middleware for you. This is unlike `grunt-contrib-connect`, where you have to define your own middleware to do so (which has the up side of having full flexibility). Also noted that `grunt-express` will rearrange your middlewares (at runtime) to make sure `connect-livereload` is at the top of your server's middleware stack (like `connect-livereload`'s documentation has suggested).\n\nStarting v1.0, `grunt-express` also allow a dynamic list of middlewares to be passed in as option `middleware`, this is to mimic the popular `grunt-contrib-connect` [middleware feature](https://github.com/gruntjs/grunt-contrib-connect#middleware). There are some limitations on enabling this, and may not be fully funtional in all cases.\n\nUsually, we also want to control the order of loading express middlewares, because sometimes they would only function with a particular loading order. `grunt-express` tries to give you such freedom with the introduction of `placeholder` middleware. Let's see an example. Say, you have the following express script:\n\n```js\nvar express = require('express');\nvar passport = require('passport');\nvar app = express();\n\n\napp.use(express.logger('dev'));\n\n// I want to place any static content here\n// but I want to define the location of these static content in `grunt-express` options like so:\n//\n// grunt.initConfig({\n//  express: {\n//    livereloadServer: {\n//      server: path.resolve(__dirname, 'server'),\n//      bases: [path.resolve(__dirname, 'public'), path.resolve(__dirname, '.tmp')],\n//      livereload: true,\n//      serverreload: true\n//    },\n//    productionServer: {\n//      server: path.resolve(__dirname, 'server'),\n//      bases: path.resolve(__dirname, 'dist')\n//    }\n//  }\n// });\n// Notice the name of the following middleware function\napp.use(function staticsPlaceholder(req, res, next) {\n  return next();\n});\n\napp.use(express.cookieParser());\napp.use(express.session({ secret: 'i am not telling you' }));\napp.use(express.bodyParser());\n\napp.use(passport.initialize());\napp.use(passport.session());\n\n// here is where I want my dynamic middlewares be loaded\napp.use(function middlewarePlaceholder(req, res, next) {\n  return next();\n});\n\napp.use(myOtherMiddlewares);\n\nâ€¦\n\n```\n\n`grunt-exress` also support an edge case where you put the `staticsPlaceholder` middleware as part of the `middlewares` being passed in as part of the options.\n\n\n#### Multiple Servers\nYou can specify multiple servers to be run alone or simultaneously by creating a target for each server. In this example, running either `grunt express:site1` or `grunt express:site2` will  start the appropriate web server, but running `grunt connect` will run _both_. Note that any server for which the [keepalive](#keepalive) option is specified will prevent _any_ task or target from running after it.\n\n```javascript\n// Project configuration.\ngrunt.initConfig({\n  express: {\n    site1: {\n      options: {\n        port: 9000,\n        bases: 'www-roots/site1'\n      }\n    },\n    site2: {\n      options: {\n        port: 9001,\n        bases: 'www-roots/site2'\n      }\n    }\n  }\n});\n```\n\n#### Custom express\nLike the [Basic Use](#basic-use) example, this example will start a static web server at `http://localhost:9001/`, with its base path set to the `www-root` directory relative to the gruntfile. Unlike the other example, this will use your custom server script as referred to by `server`! We also set `keepalive` and `watchChanges` to true, so the server will run forever (until you terminate the command), also the server will restart when you apply any changes to your server script.\n\n```javascript\n// Project configuration.\ngrunt.initConfig({\n  express: {\n    custom: {\n      options: {\n        port: 9001,\n        bases: 'www-root',\n        server: path.resolve('./server/main')\n      }\n    }\n  }\n});\n```\n\nany in your `server/main.js`, we reuse the previous sample server script\n```javascript\nvar express = require('express');\nvar app = express();\napp.get('/', function(req, res) {\n  res.send('hello!');\n});\nmodule.exports = app;\n```\n(open [localhost:9001](http://localhost:9001) and you should see \"hello!\")\n\nNow let's change `server/main.js`'s content to:\n```javascript\nvar express = require('express');\nvar app = express();\napp.get('/', function(req, res) {\n  res.send('bonjour!');\n});\nmodule.exports = app;\n```\n(refresh browser and you should see \"bonjour!\")\n\n\n## Release History\n * 2013-07-16 `v1.0.0-beta` use grunt-contrib-watch, support both serverreload and livereload\n * 2013-04-25 `v0.3.3` use forever-monitor npm v1.2.1\n * 2013-03-24 `v0.3.2` fixed npm v1.2.15 compatibility issue\n * 2013-03-14 `v0.3.0` support 'debug-brk' option for launching server in child process (so it can be linked to a remote debugger); also point forever-monitor dependency to its github verion (has fix for accepting 'debug-brk' options)\n * 2013-03-13 `v0.2.2` do not defalt hostname to \"localhost\" when none is provided as that will prevent access to the server through IP addres\n * 2013-03-11 `v0.2.1` Make static directories not browsable as it breaks twitter bootstrap (suggested by @hmalphettes)\n * 2013-02-28 `v0.2.0` Switch to use forever-monitor (instead of node-supervisor). Removed \"keepalive\" option, instead enable the feature using \"express-keepalive\" task.\n * 2013-02-25 `v0.1.3` Fixes #1, changing option \"watchChanges\" to \"supervisor\".\n * 2013-02-24 `v0.1.1` Added missing \"connect\" dependency, factored out some logic to util.js.\n * 2013-02-23 `v0.1.0` first draft.\n\n## [License-MIT](https://github.com/blai/grunt-express/blob/master/LICENSE-MIT)\n",
  "readmeFilename": "README.md",
  "_id": "grunt-express@1.2.1",
  "_from": "grunt-express@*"
}
